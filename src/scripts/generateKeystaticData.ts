#!/usr/bin/env node
/**
 * Generates static category and tag files for Keystatic configuration
 * Run this during build to update src/scripts/onbuild/categories.ts and tags.ts
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import yaml from 'js-yaml';
import { config as dotenvConfig } from 'dotenv';

// Load environment variables from .env file
dotenvConfig();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Parse frontmatter from markdown content using proper YAML parser
 * @param content - Full markdown file content
 * @returns Parsed frontmatter object or empty object if parsing fails
 */
function parseFrontmatter(content: string): any {
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) return {};

  try {
    // Use proper YAML parser instead of regex to handle all YAML features
    const parsed = yaml.load(frontmatterMatch[1]);
    return parsed || {};
  } catch (error) {
    console.error('Failed to parse YAML frontmatter:', error);
    return {};
  }
}

// Read all post files from the posts directory
function getAllPostFiles(dir: string): string[] {
  const files: string[] = [];
  const items = fs.readdirSync(dir);

  for (const item of items) {
    const fullPath = path.join(dir, item);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      // Skip _drafts directories
      if (item === '_drafts') continue;
      files.push(...getAllPostFiles(fullPath));
    } else if (item.endsWith('.md') || item.endsWith('.mdx')) {
      files.push(fullPath);
    }
  }

  return files;
}

/**
 * Validate that a tag or category string is valid
 * @param value - The value to validate
 * @returns true if valid, false otherwise
 */
function isValidKey(value: string): boolean {
  if (!value || typeof value !== 'string') return false;

  const trimmed = value.trim();

  // Must have at least one alphanumeric character
  if (!/[a-zA-Z0-9]/.test(trimmed)) return false;

  // Must not be only special characters
  if (/^[^a-zA-Z0-9]+$/.test(trimmed)) return false;

  return true;
}

// Extract categories and tags from frontmatter
function extractKeys(postFiles: string[]): { categories: Set<string>, tags: Set<string> } {
  const categories = new Set<string>();
  const tags = new Set<string>();

  for (const file of postFiles) {
    try {
      const content = fs.readFileSync(file, 'utf-8');
      const data = parseFrontmatter(content);

      // Extract categories
      if (data.categories) {
        const cats = Array.isArray(data.categories)
          ? data.categories
          : [data.categories];
        cats.forEach((cat: string) => {
          const normalized = cat.toLowerCase().trim();
          if (isValidKey(normalized)) {
            categories.add(normalized);
          } else {
            console.warn(`Skipping invalid category "${cat}" in ${path.basename(file)}`);
          }
        });
      }

      // Extract tags
      if (data.tags) {
        const tagList = Array.isArray(data.tags)
          ? data.tags
          : [data.tags];
        tagList.forEach((tag: string) => {
          const normalized = tag.toLowerCase().trim();
          if (isValidKey(normalized)) {
            tags.add(normalized);
          } else {
            console.warn(`Skipping invalid tag "${tag}" in ${path.basename(file)}`);
          }
        });
      }
    } catch (error) {
      console.error(`Failed to process ${path.basename(file)}:`, error instanceof Error ? error.message : error);
      // Continue processing other files
      continue;
    }
  }

  return { categories, tags };
}

// Main execution
// Get site code from environment variable or use default
const SITE_CODE = process.env.SITE_CODE || 'hiivelabs.com';
const postsDir = path.join(__dirname, `../assets/posts/${SITE_CODE}`);
const postFiles = getAllPostFiles(postsDir);
const { categories, tags } = extractKeys(postFiles);

// Transform both categories and tags into simple sorted arrays
const categoryList = Array.from(categories).sort();
const tagList = Array.from(tags).sort();

// Generate categories.ts content
const categoriesContent = `// Auto-generated by generateKeystaticData.ts - DO NOT EDIT MANUALLY
// Run 'npm run generate:keystatic-data' to regenerate

export const categories = ${JSON.stringify(categoryList, null, 2)};
`;

// Generate tags.ts content
const tagsContent = `// Auto-generated by generateKeystaticData.ts - DO NOT EDIT MANUALLY
// Run 'npm run generate:keystatic-data' to regenerate

export const tags = ${JSON.stringify(tagList, null, 2)};
`;

// Ensure onbuild directory exists
const onbuildDir = path.join(__dirname, 'onbuild');
if (!fs.existsSync(onbuildDir)) {
  fs.mkdirSync(onbuildDir, { recursive: true });
}

// Write files
fs.writeFileSync(path.join(onbuildDir, 'categories.ts'), categoriesContent);
fs.writeFileSync(path.join(onbuildDir, 'tags.ts'), tagsContent);

console.log('âœ… Generated categories.ts and tags.ts');
console.log(`   Categories: ${categoryList.length}`);
console.log(`   Tags: ${tagList.length}`);
