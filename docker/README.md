# Docker Setup Documentation

## Architecture

The docker setup uses two containers:

1. **blog-dev** - Runs Astro dev server with HMR
2. **build-service** - Handles production builds and git operations

## Volumes

### blog-dev-workspace
- **Mounts to:** `/app/node_modules` in blog container
- **Purpose:** Isolates node_modules from host machine
- **Persistence:** External volume that persists across container recreations
- **Auto-refresh:** Entrypoint script detects package-lock.json changes and runs `npm ci` automatically

### blog-build-workspace
- **Mounts to:** `/tmp/build-workspace` in build-service container
- **Purpose:** Workspace for production builds
- **Persistence:** External volume that persists across container recreations

## Node Modules Management

### Development (blog-dev)

The blog-dev container uses an **entrypoint script** (`docker/entrypoint.sh`) with **bind mount overlay** to maintain separate lock files.

**How it works: Bind Mount Overlay**

The container uses `mount --bind` (requires `CAP_SYS_ADMIN`) to overlay its own `package-lock.json` on top of the host's file:

```
Host's file:      /path/to/project/package-lock.json (untouched)
                           ↓ bind mount
Container's view: /app/package-lock.json → /app/node_modules/package-lock.json (in volume)
```

**Benefits:**
- ✅ Host's `package-lock.json` remains completely untouched
- ✅ Container maintains its own Linux-specific lock file in the volume
- ✅ No conflicts when running npm locally vs in docker
- ✅ Host and container lock files can coexist peacefully

**Developer Workflow:**

You can now use npm both locally and in docker without conflicts:

```bash
# On host (macOS/Windows) - generates platform-specific lock
npm install

# In docker - uses its own Linux lock file
docker-compose up -d
```

Both lock files are maintained separately. Commit whichever version you prefer (though Linux version is recommended for CI compatibility).

**How it works:**

1. On startup, creates bind mount overlay for `package-lock.json`
   - Initializes container's lock from host's (first time only)
   - Mounts container's lock at `/app/package-lock.json`
   - Host's file is hidden but unmodified
2. Checks if `package.json` is newer than `/app/node_modules/.install-timestamp`
3. If dependencies changed, runs `npm install` (reads/writes container's lock)
4. Creates timestamp marker

The bind mount persists for the container's lifetime, ensuring npm always uses the container's lock file.

**Security Note:** Requires `CAP_SYS_ADMIN` capability (configured in docker-compose.yml). This is needed for the bind mount operation and is scoped only to the container.

**Graceful Fallback:** If `CAP_SYS_ADMIN` is not granted (capability removed or restricted environment), the entrypoint will:
- Detect the mount failure and log a warning
- Fall back to shared lock file mode (container uses/modifies host's lock file)
- Continue running normally without errors

**Cross-Platform Lock Files:** The `.npmrc` file is configured with:
- `lockfile-version=3` - Uses npm 7+ format for better cross-platform consistency
- `install-strategy=hoisted` - Prevents platform-specific optional dependencies from causing lock file differences

These settings help minimize (but don't eliminate) differences between macOS and Linux lock files. For best results, commit the Linux version generated by the container.

### Production Builds (build-service)

The build-service container:

1. **Excludes node_modules and package-lock.json** from rsync copy (line 100 in build-service.py)
2. Runs `npm install --include=dev` in build directory (generates its own Linux-specific lock file)
3. Prunes dependencies with `npm prune`
4. Runs production build with fresh, clean, Linux-native dependencies

This ensures the build uses Linux-compatible dependencies, avoiding any potential issues from host platform differences (macOS/Windows lock files).

## Common Operations

### Force Rebuild node_modules

If you need to force a complete rebuild of node_modules:

```bash
# Stop the containers
docker-compose -f docker/docker-compose.yml down

# Remove the dev workspace volume
docker volume rm ${DOCKER_BLOG_CODE}-dev-workspace

# Recreate and start
docker-compose -f docker/docker-compose.yml up -d
```

The entrypoint script will detect the missing node_modules and run `npm install` on startup.

### Clear Build Cache

To clear the build workspace:

```bash
# Stop containers
docker-compose -f docker/docker-compose.yml down

# Remove build workspace
docker volume rm ${DOCKER_BLOG_CODE}-build-workspace

# Restart
docker-compose -f docker/docker-compose.yml up -d
```

### Complete Clean Slate

To remove everything and start fresh:

```bash
cd docker

# Stop and remove containers
docker-compose down

# Remove all project volumes
docker volume rm ${DOCKER_BLOG_CODE}-dev-workspace
docker volume rm ${DOCKER_BLOG_CODE}-build-workspace

# Remove network
docker network rm ${DOCKER_BLOG_CODE}-network

# Rebuild and start
docker-compose build --no-cache
docker-compose up -d
```

## Troubleshooting

### "Module not found" or dependency errors

1. Check if package-lock.json has changed:
   ```bash
   git status package-lock.json
   ```

2. If changed, restart the container to trigger automatic npm ci:
   ```bash
   docker-compose restart blog
   ```

3. If still failing, force rebuild node_modules (see above)

### Build failing with outdated dependencies

The build-service always installs fresh dependencies, but the build might be copying stale files. Check:

1. Ensure rsync is excluding node_modules (line 100 in build-service.py should have `--exclude=node_modules`)
2. Clear the build workspace volume (see above)

### HMR/WebSocket connection issues

If HMR is not connecting:

1. Ensure environment variables are set:
   ```bash
   VITE_HMR_HOST=silverfish.local  # Your external hostname
   VITE_HMR_PORT=8462              # Your external port
   ```

2. Check astro.config.mjs has HMR configuration in `vite.server.hmr`

### Keystatic lodash errors

If seeing "does not provide an export named 'default'" for lodash:

1. Check astro.config.mjs has optimizeDeps configuration:
   ```javascript
   vite: {
     optimizeDeps: {
       include: ['lodash-es'],
       exclude: ['@keystatic/core']
     }
   }
   ```

2. Clear Vite cache:
   ```bash
   docker exec -it ${DOCKER_BLOG_CODE}-blog-dev rm -rf /app/node_modules/.vite
   docker-compose restart blog
   ```

## Environment Variables

Required in `.env` file:

```bash
# Docker configuration
DOCKER_BLOG_CODE=mysite        # Prefix for container/volume names
DOCKER_BLOG_PORT=8462          # External port for dev server
DOCKER_BUILD_MODE=pip          # or 'uv' for alternative build image

# HMR configuration (for docker)
VITE_HMR_HOST=silverfish.local # External hostname
VITE_HMR_PORT=8462            # External port (same as DOCKER_BLOG_PORT)

# Site configuration
SITE_CODE=hiivelabs.com
VITE_SITE_NAME=https://hiivelabs.com
ROOT_URL=https://hiivelabs.com

# Git credentials (for build-service push)
GITHUB_TOKEN=ghp_xxxxx
```

## Architecture Decisions

### Why external volumes?

External volumes persist across container recreations, which:
- Speeds up container restarts (no reinstall needed)
- Preserves build artifacts
- Allows for explicit volume management

### Why exclude node_modules from rsync?

The host's node_modules might:
- Not exist (if developer uses docker-only workflow)
- Be for wrong platform (macOS vs Linux)
- Be stale or corrupted
- Contain dev-only dependencies

By excluding and reinstalling fresh, we ensure clean, correct dependencies for production builds.

### Why use entrypoint script instead of always running npm ci?

Running `npm ci` on every container start adds ~30-60 seconds startup time. The entrypoint script:
- Checks timestamps to detect changes
- Only reinstalls when needed
- Preserves fast startup for unchanged dependencies
